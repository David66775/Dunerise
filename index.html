<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
  <script>alert("website under construction: online multiplayer may break);</script>
<title>Dunerise Multiplayer</title>

<!-- YJS & WebRTC (non-blocking, modern usage) -->
<script type="module">
  import * as Y from 'https://unpkg.com/yjs@13.6.10/dist/yjs.mjs';
  import { WebrtcProvider } from 'https://unpkg.com/y-webrtc@10.3.10/dist/y-webrtc.mjs';
  window.Y = Y;
  window.WebrtcProvider = WebrtcProvider;
</script>

<style>
body { margin:0; overflow:hidden; background-color:#eee; }
canvas { display:block; background-color:skyblue; }

/* Hamburger Menu Icon Styling */
.menu-toggle {
    position: absolute; top: 20px; right: 20px;
    width:50px; height:50px; background-color: rgba(0,0,0,0.5);
    border-radius:50%; cursor:pointer; display:flex; flex-direction:column;
    justify-content:center; align-items:center; z-index:10; transition:0.3s;
}
.menu-toggle:hover { transform: scale(1.1); }
.bar { width:60%; height:4px; background:white; margin:3px 0; transition:0.4s; }
.menu-toggle.active .bar:nth-child(2) { opacity:0; }
.menu-toggle.active .bar:nth-child(1) { transform:translateY(7px) rotate(45deg); }
.menu-toggle.active .bar:nth-child(3) { transform:translateY(-7px) rotate(-45deg); }

/* Menu Container Styling */
.menu-container {
    position: fixed; top:0; right:-300px; width:300px; height:100%;
    background-color: rgba(50,50,50,0.95); color:white; padding:20px;
    box-sizing:border-box; transition:right 0.4s ease; z-index:5; font-family:sans-serif;
}
.menu-container.active { right:0; }
.menu-container h2 { margin-top:50px; }
.menu-container div { margin-bottom:10px; padding:5px; background-color: rgba(255,255,255,0.1); border-radius:4px; }
.menu-container button { margin:5px 2px; padding:5px 10px; border:none; border-radius:4px; cursor:pointer; background-color:#666; color:white; }
.menu-container button:hover { background-color:#888; }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<!-- Hamburger Menu Icon -->
<div class="menu-toggle" id="menuToggle">
  <div class="bar"></div>
  <div class="bar"></div>
  <div class="bar"></div>
</div>

<!-- Stats Menu -->
<div class="menu-container" id="statsMenu">
  <h2>Game Stats</h2>
  <div>High Score: <span id="highScore">0</span></div>
  <div>Total Movement: <span id="totalMovement">0</span></div>
  <div>Times Played: <span id="timesPlayed">0</span></div>
  <hr>
  <h3>Number of Players</h3>
  <div>
    <button onclick="setPlayerCount(1)">1</button>
    <button onclick="setPlayerCount(2)">2</button>
    <button onclick="setPlayerCount(3)">3</button>
    <button onclick="setPlayerCount(4)">4</button>
  </div>
  <hr>
  <h3>Online Channel</h3>
  <input type="number" id="channel-input" placeholder="Channel #" style="width:90%; padding:5px; margin-bottom:10px;">
  <div>
    <button onclick="hostChannel()">Host</button>
    <button onclick="joinChannel()">Join</button>
  </div>
  <div style="font-size:12px; margin-top:5px;">Up to 4 players per channel</div>
</div>

<script>
window.addEventListener('load', () => {

  // --- Canvas setup ---
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  let canvasWidth = window.innerWidth;
  let canvasHeight = window.innerHeight;
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  // --- Stats ---
  let highScore = parseInt(localStorage.getItem('highScore')) || 0;
  let totalMovement = parseInt(localStorage.getItem('totalMovement')) || 0;
  let timesPlayed = parseInt(localStorage.getItem('timesPlayed')) || 0;

  // --- Terrain ---
  const world = new Map();
  const CHUNK_SIZE = 512;
  const maxSteepness = 5;
  const maxChange = 2;
  const baseTerrainHeight = canvasHeight*0.6;
  const SPAWN_X = 50;
  const SUN_RADIUS = 50;
  const DIRT_COLOR = '#8B4513';
  const GRASS_COLOR = '#e4dc8a';
  const HOLE_CHANCE = 0.5;

  // --- Players ---
  const playerConfigs = [
    { jump:'w', left:'a', right:'d', color:'#ff5733' },
    { jump:'5', left:'r', right:'y', color:'#006400' },
    { jump:'o', left:'k', right:';', color:'#3357ff' },
    { jump:'f', left:'c', right:'b', color:'#ff33aa' },
  ];
  let players = [];
  let maxPlayers = 1;
  let previousWorldX = SPAWN_X;

  function setPlayerCount(count){
    maxPlayers = count;
    restartGame();
  }

  // --- Terrain generation ---
  function generateChunk(chunkX,startHeight=baseTerrainHeight,startSteepness=0){
    if(world.has(chunkX)) return;
    const terrainData=[];
    let currentHeight=startHeight;
    let steepness=startSteepness;
    const hasHole = Math.random()<HOLE_CHANCE && chunkX>0;
    const holeStart = hasHole ? Math.floor(Math.random()*(CHUNK_SIZE-50)):-1;
    const holeEnd = hasHole ? holeStart+150:-1;
    for(let x=0;x<CHUNK_SIZE;x++){
      if(hasHole && x>=holeStart && x<=holeEnd){
        terrainData.push(canvasHeight+100);
      } else {
        steepness += (Math.random()-0.5)*maxChange*2;
        steepness = Math.min(Math.max(steepness,-maxSteepness),maxSteepness);
        currentHeight += steepness;
        currentHeight = Math.min(Math.max(currentHeight,canvasHeight*0.3),canvasHeight*0.9);
        terrainData.push(currentHeight);
      }
    }
    world.set(chunkX,{x:chunkX*CHUNK_SIZE,data:terrainData,endHeight:currentHeight,endSteepness:steepness});
  }
  function getTerrainHeightAt(worldX){
    const chunkX = Math.floor(worldX/CHUNK_SIZE);
    const localX = worldX % CHUNK_SIZE;
    const chunk = world.get(chunkX);
    if(chunk) return chunk.data[Math.floor(localX)];
    return baseTerrainHeight;
  }

  // --- Restart game ---
  function restartGame(){
    players=[];
    for(let i=0;i<maxPlayers;i++){
      players.push({
        id:i, x:50, y:0, radius:10, speed:5,
        vx:0, vy:0, gravity:0.5, onGround:false,
        worldX:SPAWN_X, color:playerConfigs[i].color, score:0
      });
    }
    previousWorldX=SPAWN_X;
    world.clear();
    generateChunk(0);
  }

  // --- Player movement ---
  const keys = {};
  function updatePlayers(){
    let sumWorldX = 0;
    players.forEach((player,i)=>{
      const cfg = playerConfigs[i];
      if(keys[cfg.left]) player.vx=-player.speed;
      else if(keys[cfg.right]) player.vx=player.speed;
      else player.vx=0;
      if(keys[cfg.jump] && player.onGround){
        player.vy=-10; player.onGround=false;
      }
      player.worldX += player.vx;
      player.y += player.vy;
      if(player.y>canvasHeight+50){
        player.worldX=SPAWN_X; player.y=0; player.vx=0; player.vy=0; player.onGround=false;
      }
      const groundY = getTerrainHeightAt(player.worldX)-player.radius;
      if(player.y>=groundY){ player.y=groundY; player.vy=0; player.onGround=true; }
      else { player.vy+=player.gravity; player.onGround=false; }
      player.score=Math.floor(player.worldX-SPAWN_X);
      if(player.score>highScore) highScore=player.score;
      sumWorldX += player.worldX;
    });
    const avgWorldX = sumWorldX/players.length;
    if(avgWorldX>previousWorldX) totalMovement += (avgWorldX-previousWorldX);
    previousWorldX = avgWorldX;
  }

  // --- Camera & chunks ---
  const camera={x:0};
  function updateCameraAndChunks(){
    const avgX = players.reduce((s,p)=>s+p.worldX,0)/players.length;
    camera.x = Math.max(0, avgX - canvasWidth/2);
    const startChunkX = Math.floor(camera.x/CHUNK_SIZE);
    const endChunkX = Math.floor((camera.x+canvasWidth)/CHUNK_SIZE);
    for(let cx=startChunkX-1; cx<=endChunkX+1; cx++){
      if(!world.has(cx)){
        const prevChunk=world.get(cx-1);
        if(prevChunk) generateChunk(cx,prevChunk.endHeight,prevChunk.endSteepness);
        else generateChunk(cx);
      }
    }
  }

  // --- Drawing ---
  function drawTerrain(){
    ctx.fillStyle=DIRT_COLOR;
    for(const [chunkKey,chunk] of world){
      if(chunk.x+CHUNK_SIZE>camera.x && chunk.x<camera.x+canvasWidth){
        ctx.beginPath();
        ctx.moveTo(chunk.x-camera.x,canvasHeight);
        for(let i=0;i<CHUNK_SIZE;i++) ctx.lineTo(chunk.x+i-camera.x,chunk.data[i]);
        ctx.lineTo(chunk.x+CHUNK_SIZE-camera.x,canvasHeight);
        ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(chunk.x-camera.x,chunk.data[0]);
        for(let i=0;i<CHUNK_SIZE;i++) ctx.lineTo(chunk.x+i-camera.x,chunk.data[i]);
        ctx.strokeStyle=GRASS_COLOR; ctx.lineWidth=2; ctx.stroke();
      }
    }
  }
  function drawPlayers(){
    players.forEach(player=>{
      const screenX = player.worldX-camera.x;
      ctx.beginPath();
      ctx.arc(screenX,player.y,player.radius,0,Math.PI*2);
      ctx.fillStyle = player.color; ctx.fill(); ctx.closePath();
    });
  }
  function drawSun(){
    const sunX=SUN_RADIUS+30, sunY=SUN_RADIUS+30;
    ctx.beginPath(); ctx.arc(sunX,sunY,SUN_RADIUS,0,Math.PI*2); ctx.fillStyle='#FFD700'; ctx.fill(); ctx.closePath();
    ctx.strokeStyle='#FFD700'; ctx.lineWidth=3;
    const numRays=16;
    for(let i=0;i<numRays;i++){
      const angle = (i/numRays)*Math.PI*2;
      const startX = sunX+Math.cos(angle)*(SUN_RADIUS+5);
      const startY = sunY+Math.sin(angle)*(SUN_RADIUS+5);
      const endX = sunX+Math.cos(angle)*(SUN_RADIUS+25);
      const endY = sunY+Math.sin(angle)*(SUN_RADIUS+25);
      ctx.beginPath(); ctx.moveTo(startX,startY); ctx.lineTo(endX,endY); ctx.stroke();
    }
  }
  function displayScore(){
    const avgScore = players.reduce((s,p)=>s+p.score,0)/players.length;
    ctx.fillStyle='#000'; ctx.font='40px Arial'; ctx.textAlign='center';
    ctx.fillText(`Score: ${Math.floor(avgScore)}`, canvasWidth/2, 50);
  }
  function updateStats(){
    localStorage.setItem('highScore',highScore);
    localStorage.setItem('totalMovement',Math.floor(totalMovement));
    localStorage.setItem('timesPlayed',timesPlayed);
    document.getElementById('highScore').textContent=highScore;
    document.getElementById('totalMovement').textContent=Math.floor(totalMovement);
    document.getElementById('timesPlayed').textContent=timesPlayed;
  }

  // --- Menu toggle ---
  const menuToggle = document.getElementById('menuToggle');
  const statsMenu = document.getElementById('statsMenu');
  menuToggle.addEventListener('click',()=>{
    menuToggle.classList.toggle('active');
    statsMenu.classList.toggle('active');
  });

  // --- Input ---
  document.addEventListener('keydown',e=>{ keys[e.key.toLowerCase()]=true; });
  document.addEventListener('keyup',e=>{ keys[e.key.toLowerCase()]=false; });

  // --- Resize ---
  window.addEventListener('resize',()=>{
    canvasWidth=window.innerWidth; canvasHeight=window.innerHeight;
    canvas.width=canvasWidth; canvas.height=canvasHeight;
    world.clear();
    generateChunk(Math.floor(players[0].worldX/CHUNK_SIZE));
  });

  // --- Times played ---
  if(!localStorage.getItem('gameInitialized')){
    timesPlayed=1;
    localStorage.setItem('gameInitialized','true');
  } else {
    timesPlayed = parseInt(localStorage.getItem('timesPlayed'))||0;
    timesPlayed++;
    localStorage.setItem('timesPlayed',timesPlayed);
  }

  // --- Multiplayer setup ---
  let ydoc = null;
  let provider = null;
  let yPlayers = null;
  let isHost = false;
  let myPlayerIndex = 0;

  function hostChannel(){
    const channel = parseInt(document.getElementById('channel-input').value);
    if(isNaN(channel)){ alert('Enter a valid channel number'); return; }
    isHost = true;
    ydoc = new Y.Doc();
    provider = new WebrtcProvider('dunerise-'+channel, ydoc);
    yPlayers = ydoc.getArray('players');

    if(yPlayers.length === 0){
      for(let i=0;i<4;i++){ yPlayers.push([SPAWN_X,0,false,0]); }
    }
    myPlayerIndex = 0;
    maxPlayers = 4;
    restartGame();

    // Low latency observer
    yPlayers.observe(event=>{
      yPlayers.forEach((val,i)=>{
        if(i<players.length && !isHost){
          players[i].worldX = val[0];
          players[i].y = val[1];
          players[i].onGround = val[2];
          players[i].score = val[3];
        }
      });
    });

    requestAnimationFrame(syncLoop);
  }

  function joinChannel(){
    const channel = parseInt(document.getElementById('channel-input').value);
    if(isNaN(channel)){ alert('Enter a valid channel number'); return; }
    isHost = false;
    ydoc = new Y.Doc();
    provider = new WebrtcProvider('dunerise-'+channel, ydoc);
    yPlayers = ydoc.getArray('players');

    // Wait until host has created slots
    const waitForHost = setInterval(()=>{
      if(yPlayers.length>0){
        clearInterval(waitForHost);
        myPlayerIndex = pickFreeSlot();
        maxPlayers = 4;
        restartGame();

        yPlayers.observe(event=>{
          yPlayers.forEach((val,i)=>{
            if(i<players.length && !isHost){
              players[i].worldX = val[0];
              players[i].y = val[1];
              players[i].onGround = val[2];
              players[i].score = val[3];
            }
          });
        });

        requestAnimationFrame(syncLoop);
      }
    },300);
  }

  // Pick first free slot
  function pickFreeSlot(){
    for(let i=0;i<yPlayers.length;i++){
      let p=yPlayers.get(i);
      if(p[0]===SPAWN_X && p[1]===0) return i;
    }
    return -1;
  }

  // Sync host player positions
  function syncLoop(){
    if(isHost && yPlayers){
      players.forEach((p,i)=>{
        if(i<yPlayers.length){
          yPlayers.set(i,[p.worldX,p.y,p.onGround,p.score]);
        }
      });
    }
    requestAnimationFrame(syncLoop);
  }

  // --- Expose globally ---
  window.hostChannel = hostChannel;
  window.joinChannel = joinChannel;

  // --- Game loop ---
  function gameLoop(){
    ctx.clearRect(0,0,canvasWidth,canvasHeight);
    updatePlayers();
    updateCameraAndChunks();
    drawSun();
    drawTerrain();
    drawPlayers();
    displayScore();
    updateStats();
    requestAnimationFrame(gameLoop);
  }

  restartGame();
  gameLoop();

});
</script>
</body>
</html>
