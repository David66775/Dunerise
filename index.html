<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Dunerise Multiplayer</title>

<!-- Y.js + WebRTC (UMD builds, global Y and WebrtcProvider available) -->
<script src="https://cdn.jsdelivr.net/npm/yjs@13.6.10/dist/yjs.js"></script>
<script src="https://cdn.jsdelivr.net/npm/y-webrtc@10.3.10/dist/y-webrtc.js"></script>

<style>
body { margin:0; overflow:hidden; background-color:#eee; }
canvas { display:block; background-color:skyblue; }

.menu-toggle {
    position:absolute; top:20px; right:20px;
    width:50px; height:50px; background-color:rgba(0,0,0,0.5);
    border-radius:50%; cursor:pointer; display:flex; flex-direction:column;
    justify-content:center; align-items:center; z-index:10; transition:0.3s;
}
.menu-toggle:hover { transform:scale(1.1); }
.bar { width:60%; height:4px; background:white; margin:3px 0; transition:0.4s; }
.menu-toggle.active .bar:nth-child(2) { opacity:0; }
.menu-toggle.active .bar:nth-child(1) { transform:translateY(7px) rotate(45deg); }
.menu-toggle.active .bar:nth-child(3) { transform:translateY(-7px) rotate(-45deg); }

.menu-container {
    position:fixed; top:0; right:-300px; width:300px; height:100%;
    background-color:rgba(50,50,50,0.95); color:white; padding:20px;
    box-sizing:border-box; transition:right 0.4s ease; z-index:5;
    font-family:sans-serif;
}
.menu-container.active { right:0; }
.menu-container h2 { margin-top:50px; }
.menu-container div { margin-bottom:10px; padding:5px; background-color:rgba(255,255,255,0.1); border-radius:4px; }
.menu-container button { margin:5px 2px; padding:5px 10px; border:none; border-radius:4px;
                         cursor:pointer; background-color:#666; color:white; }
.menu-container button:hover { background-color:#888; }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<!-- Hamburger menu -->
<div class="menu-toggle" id="menuToggle">
  <div class="bar"></div>
  <div class="bar"></div>
  <div class="bar"></div>
</div>

<!-- Stats + multiplayer settings -->
<div class="menu-container" id="statsMenu">
  <h2>Game Stats</h2>
  <div>High Score: <span id="highScore">0</span></div>
  <div>Total Movement: <span id="totalMovement">0</span></div>
  <div>Times Played: <span id="timesPlayed">0</span></div>
  <hr>
  <h3>Number of Players</h3>
  <div>
    <button onclick="setPlayerCount(1)">1</button>
    <button onclick="setPlayerCount(2)">2</button>
    <button onclick="setPlayerCount(3)">3</button>
    <button onclick="setPlayerCount(4)">4</button>
  </div>
  <hr>
  <h3>Online Channel</h3>
  <input type="number" id="channel-input" placeholder="Channel #" style="width:90%; padding:5px; margin-bottom:10px;">
  <div>
    <button onclick="hostChannel()">Host</button>
    <button onclick="joinChannel()">Join</button>
  </div>
  <div style="font-size:12px; margin-top:5px;">Up to 4 players per channel</div>
</div>

<script>
window.onload = function() {
  //================================================================================
  // CANVAS
  //================================================================================
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  let canvasWidth = window.innerWidth;
  let canvasHeight = window.innerHeight;
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  //================================================================================
  // STATS (local)
  //================================================================================
  let highScore = parseInt(localStorage.getItem('highScore')) || 0;
  let totalMovement = parseInt(localStorage.getItem('totalMovement')) || 0;
  let timesPlayed = parseInt(localStorage.getItem('timesPlayed')) || 0;

  //================================================================================
  // TERRAIN CONSTANTS
  //================================================================================
  const world = new Map();
  const CHUNK_SIZE = 512;
  const baseTerrainHeight = canvasHeight * 0.6;
  const maxSteepness = 5;
  const maxChange = 2;
  const SPAWN_X = 50;
  const SUN_RADIUS = 50;
  const DIRT_COLOR = '#8B4513';
  const GRASS_COLOR = '#e4dc8a';
  const HOLE_CHANCE = 0.5;

  //================================================================================
  // PLAYERS + CONTROL BINDINGS
  //================================================================================
  const playerConfigs = [
    { jump:'w', left:'a', right:'d', color:'#ff5733' },
    { jump:'5', left:'r', right:'y', color:'#006400' },
    { jump:'o', left:'k', right:';', color:'#3357ff' },
    { jump:'f', left:'c', right:'b', color:'#ff33aa' },
  ];

  let players = [];
  let maxPlayers = 1;
  let previousWorldX = SPAWN_X;

  function setPlayerCount(count){
    maxPlayers = count;
    restartGame();
  }

  //================================================================================
  // TERRAIN GENERATION
  //================================================================================
  function generateChunk(chunkX,startHeight=baseTerrainHeight,startSteepness=0){
    if(world.has(chunkX)) return;
    const terrainData=[];
    let currentHeight=startHeight;
    let steepness=startSteepness;

    let hasHole = Math.random()<HOLE_CHANCE && chunkX>0;
    let holeStart = hasHole ? Math.floor(Math.random()*(CHUNK_SIZE-50)) : -1;
    let holeEnd   = hasHole ? holeStart+150 : -1;

    for(let x=0;x<CHUNK_SIZE;x++){
      if(hasHole && x>=holeStart && x<=holeEnd){
        terrainData.push(canvasHeight+100);  // drop-off hole
      } else {
        steepness += (Math.random()-0.5)*maxChange*2;
        steepness = Math.min(Math.max(steepness,-maxSteepness),maxSteepness);
        currentHeight += steepness;
        currentHeight = Math.min(Math.max(currentHeight,canvasHeight*0.3),canvasHeight*0.9);
        terrainData.push(currentHeight);
      }
    }

    world.set(chunkX,{
      x:chunkX*CHUNK_SIZE,
      data:terrainData,
      endHeight:currentHeight,
      endSteepness:steepness
    });
  }

  function getTerrainHeightAt(worldX){
    const chunkX = Math.floor(worldX/CHUNK_SIZE);
    const localX = Math.floor(worldX % CHUNK_SIZE);
    const chunk = world.get(chunkX);
    if(chunk && chunk.data[localX] !== undefined) return chunk.data[localX];
    return baseTerrainHeight;
  }

  //================================================================================
  // GAME RESET
  //================================================================================
  function restartGame(){
    players=[];
    for(let i=0;i<maxPlayers;i++){
      players.push({
        id:i, x:50, y:0, radius:10,
        vx:0, vy:0, speed:5,
        gravity:0.5,
        onGround:false,
        worldX:SPAWN_X, color:playerConfigs[i].color, score:0
      });
    }
    previousWorldX=SPAWN_X;
    world.clear();
    generateChunk(0);
  }

  //================================================================================
  // INPUT
  //================================================================================
  const keys = {};
  document.addEventListener('keydown',e=>{ keys[e.key.toLowerCase()]=true; });
  document.addEventListener('keyup',e=>{ keys[e.key.toLowerCase()]=false; });

  //================================================================================
  // PLAYER UPDATE
  //================================================================================
  function updatePlayers(){
    let sumWorldX=0;
    players.forEach((player,i)=>{
      const cfg = playerConfigs[i];

      // Movement
      if(keys[cfg.left]) player.vx = -player.speed;
      else if(keys[cfg.right]) player.vx = player.speed;
      else player.vx = 0;

      // Jump
      if(keys[cfg.jump] && player.onGround){
        player.vy = -10;
        player.onGround=false;
      }

      // Apply
      player.worldX += player.vx;
      player.y += player.vy;

      // Fail reset
      if(player.y > canvasHeight+100){
        player.worldX = SPAWN_X;
        player.y = 0;
        player.vx = 0;
        player.vy = 0;
        player.onGround = false;
      }

      // Terrain collision
      const groundY = getTerrainHeightAt(player.worldX)-player.radius;
      if(player.y >= groundY){
        player.y = groundY;
        player.vy = 0;
        player.onGround=true;
      } else {
        player.vy += player.gravity;
        player.onGround=false;
      }

      // Score
      player.score = Math.floor(player.worldX - SPAWN_X);
      if(player.score > highScore) highScore = player.score;

      sumWorldX += player.worldX;
    });

    const avgWorldX = players.length ? sumWorldX/players.length : previousWorldX;
    if(avgWorldX > previousWorldX) totalMovement += (avgWorldX-previousWorldX);
    previousWorldX = avgWorldX;
  }

  //================================================================================
  // CAMERA
  //================================================================================
  const camera={x:0};

  function updateCameraAndChunks(){
    const avgX = players.reduce((s,p)=>s+p.worldX,0)/players.length;
    camera.x = Math.max(0, avgX - canvasWidth/2);

    const startChunkX = Math.floor(camera.x/CHUNK_SIZE);
    const endChunkX = Math.floor((camera.x+canvasWidth)/CHUNK_SIZE);

    for(let cx=startChunkX-1; cx<=endChunkX+1; cx++){
      if(!world.has(cx)){
        const prev = world.get(cx-1);
        if(prev) generateChunk(cx, prev.endHeight, prev.endSteepness);
        else     generateChunk(cx);
      }
    }
  }

  //================================================================================
  // RENDERING
  //================================================================================
  function drawTerrain(){
    ctx.fillStyle=DIRT_COLOR;

    for(const [chunkKey,chunk] of world){
      if(chunk.x+CHUNK_SIZE > camera.x && chunk.x < camera.x+canvasWidth){

        // Fill ground
        ctx.beginPath();
        ctx.moveTo(chunk.x-camera.x,canvasHeight);
        for(let i=0;i<CHUNK_SIZE;i++)
          ctx.lineTo(chunk.x+i-camera.x,chunk.data[i]);
        ctx.lineTo(chunk.x+CHUNK_SIZE-camera.x,canvasHeight);
        ctx.closePath();
        ctx.fill();

        // Grass line
        ctx.beginPath();
        ctx.moveTo(chunk.x-camera.x,chunk.data[0]);
        for(let i=0;i<CHUNK_SIZE;i++)
          ctx.lineTo(chunk.x+i-camera.x,chunk.data[i]);
        ctx.strokeStyle=GRASS_COLOR;
        ctx.lineWidth=2;
        ctx.stroke();
      }
    }
  }

  function drawPlayers(){
    players.forEach(p=>{
      const screenX = p.worldX-camera.x;
      ctx.beginPath();
      ctx.arc(screenX,p.y,p.radius,0,Math.PI*2);
      ctx.fillStyle=p.color;
      ctx.fill();
      ctx.closePath();
    });
  }

  function drawSun(){
    const sx=SUN_RADIUS+30, sy=SUN_RADIUS+30;
    ctx.beginPath();
    ctx.arc(sx,sy,SUN_RADIUS,0,Math.PI*2);
    ctx.fillStyle='#FFD700';
    ctx.fill();
    ctx.closePath();

    ctx.strokeStyle='#FFD700';
    ctx.lineWidth=3;
    const numRays=16;
    for(let i=0;i<numRays;i++){
      const angle = (i/numRays)*Math.PI*2;
      const x1 = sx + Math.cos(angle)*(SUN_RADIUS+5);
      const y1 = sy + Math.sin(angle)*(SUN_RADIUS+5);
      const x2 = sx + Math.cos(angle)*(SUN_RADIUS+25);
      const y2 = sy + Math.sin(angle)*(SUN_RADIUS+25);
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
    }
  }

  function displayScore(){
    const avg = players.reduce((s,p)=>s+p.score,0)/players.length;
    ctx.fillStyle='#000';
    ctx.font='40px Arial';
    ctx.textAlign='center';
    ctx.fillText(`Score: ${Math.floor(avg)}`, canvasWidth/2, 50);
  }

  function updateStats(){
    localStorage.setItem('highScore',highScore);
    localStorage.setItem('totalMovement',Math.floor(totalMovement));
    localStorage.setItem('timesPlayed',timesPlayed);

    document.getElementById('highScore').textContent=highScore;
    document.getElementById('totalMovement').textContent=Math.floor(totalMovement);
    document.getElementById('timesPlayed').textContent=timesPlayed;
  }

  //================================================================================
  // MENU
  //================================================================================
  const menuToggle=document.getElementById('menuToggle');
  const statsMenu=document.getElementById('statsMenu');

  menuToggle.addEventListener('click',()=>{
    menuToggle.classList.toggle('active');
    statsMenu.classList.toggle('active');
  });

  //================================================================================
  // RESIZE
  //================================================================================
  window.addEventListener('resize',()=>{
    canvasWidth = window.innerWidth;
    canvasHeight = window.innerHeight;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    world.clear();
    generateChunk(Math.floor(players[0]?.worldX/CHUNK_SIZE || 0));
  });

  //================================================================================
  // TIMES PLAYED
  //================================================================================
  if(!localStorage.getItem('gameInitialized')){
    timesPlayed = 1;
    localStorage.setItem('gameInitialized','true');
  } else {
    timesPlayed = parseInt(localStorage.getItem('timesPlayed'))||0;
    timesPlayed++;
    localStorage.setItem('timesPlayed',timesPlayed);
  }

  //================================================================================
  // MULTIPLAYER (HOST + CLIENT)
  //================================================================================
  let ydoc=null;
  let provider=null;
  let yPlayers=null;
  let yInputs=null;      // NEW: each client writes input to this
  let isHost=false;
  let myPlayerIndex=-1;

  // Write a player's state into Y
  function writePlayerToY(index,arr){
    if(!yPlayers) return;

    const snap = yPlayers.toArray();

    if(index < snap.length){
      yPlayers.delete(index,1);
      yPlayers.insert(index,[arr]);
    } else {
      // Fill missing slots
      while(snap.length < index){
        snap.push([SPAWN_X,0,false,0]);
      }
      yPlayers.insert(index, [arr]);
    }
  }

  //================================================================================
  // CLIENT â†’ HOST INPUT SYNC
  //================================================================================
  function writeMyInput(){
    if(!yInputs || myPlayerIndex<0) return;

    const cfg = playerConfigs[myPlayerIndex];
    const inp = [
      keys[cfg.left] ? 1 : 0,
      keys[cfg.right]? 1 : 0,
      keys[cfg.jump] ? 1 : 0
    ];

    yInputs.set(myPlayerIndex, inp);
  }

  //================================================================================
  // HOST READS ALL INPUTS AND MOVES REMOTE PLAYERS
  //================================================================================
  function applyRemoteInputs(){
    if(!isHost || !yInputs) return;

    for(let i=0;i<players.length;i++){
      const inp = yInputs.get(i);
      if(!inp) continue;

      const cfg = playerConfigs[i];
      const player = players[i];

      // left/right
      if(inp[0]) player.vx = -player.speed;
      else if(inp[1]) player.vx = player.speed;
      else player.vx = 0;

      // jump
      if(inp[2] && player.onGround){
        player.vy = -10;
        player.onGround=false;
      }
    }
  }

  //================================================================================
  // FREE SLOT PICKER
  //================================================================================
  function pickFreeSlot(){
    const snap=yPlayers.toArray();
    for(let i=0;i<snap.length;i++){
      const p = snap[i];
      if(p[0] === SPAWN_X && p[1] === 0) return i;
    }
    return -1;
  }

  //================================================================================
  // HOST
  //================================================================================
  function hostChannel(){
    const channel=parseInt(document.getElementById('channel-input').value);
    if(isNaN(channel)){ alert('Enter a valid channel number'); return; }

    isHost=true;
    ydoc = new Y.Doc();
    provider = new window.WebrtcProvider('dunerise-'+channel, ydoc);

    yPlayers = ydoc.getArray('players');
    yInputs  = ydoc.getMap('inputs');

    // Initialize 4 slots if empty
    if(yPlayers.toArray().length===0){
      yPlayers.insert(0,[
        [SPAWN_X,0,false,0],
        [SPAWN_X,0,false,0],
        [SPAWN_X,0,false,0],
        [SPAWN_X,0,false,0]
      ]);
    }

    myPlayerIndex = 0;
    maxPlayers = 4;
    restartGame();

    yPlayers.observe(()=>{
      if(!isHost){
        const snap=yPlayers.toArray();
        snap.forEach((p,i)=>{
          if(i<players.length){
            players[i].worldX = p[0];
            players[i].y      = p[1];
            players[i].onGround = p[2];
            players[i].score  = p[3];
          }
        });
      }
    });
  }
    requestAnimationFrame(syncLoop);

  //================================================================================
  // CLIENT
  //================================================================================
  function joinChannel(){
    const channel=parseInt(document.getElementById('channel-input').value);
    if(isNaN(channel)){ alert('Enter a valid channel number'); return; }

    isHost=false;
    ydoc = new Y.Doc();
    provider = new window.WebrtcProvider('dunerise-'+channel, ydoc);
    yPlayers = ydoc.getArray('players');
    yInputs  = ydoc.getMap('inputs');

    const wait = setInterval(()=>{
      const snap=yPlayers.toArray();
      if(snap.length>0) {
        clearInterval(wait);

        myPlayerIndex = pickFreeSlot();
        if(myPlayerIndex === -1){
          alert("Server full");
          return;
        }

        maxPlayers=4;
        restartGame();

        yPlayers.observe(()=>{
          const snap=yPlayers.toArray();
          snap.forEach((p,i)=>{
            if(i<players.length){
              players[i].worldX = p[0];
              players[i].y      = p[1];
              players[i].onGround = p[2];
              players[i].score  = p[3];
            }
          });
        });

        requestAnimationFrame(syncLoop);
      }
    },300);
  }

  //================================================================================
  // MASTER SYNC LOOP
  //================================================================================
  function syncLoop(){

    if(isHost){
      applyRemoteInputs();

      for(let i=0;i<players.length;i++){
        const p=players[i];
        writePlayerToY(i,[p.worldX,p.y,!!p.onGround,p.score]);
      }

    } else {
      writeMyInput();
    }

    requestAnimationFrame(syncLoop);
  }

  //================================================================================
  // PUBLIC FUNCTIONS
  //================================================================================
  window.hostChannel = hostChannel;
  window.joinChannel = joinChannel;

  //================================================================================
  // MAIN GAME LOOP
  //================================================================================
  function gameLoop(){
    ctx.clearRect(0,0,canvasWidth,canvasHeight);

    updatePlayers();
    updateCameraAndChunks();
    drawSun();
    drawTerrain();
    drawPlayers();
    displayScore();
    updateStats();

    requestAnimationFrame(gameLoop);
  }

  restartGame();
  gameLoop();
  }
</script>
</body>
</html>
