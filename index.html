<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<script src="https://unpkg.com/yjs@13.6.10/dist/yjs.js"></script>
<script src="https://unpkg.com/y-webrtc@10.3.10/dist/y-webrtc.js"></script>
<title>Dunerise Multiplayer</title>
<style>
    body { margin: 0; overflow: hidden; background-color: #eee; }
    canvas { display: block; background-color: skyblue;}

    /* Hamburger Menu Icon Styling */
    .menu-toggle {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 50px;
        height: 50px;
        background-color: rgba(0, 0, 0, 0.5);
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10;
        transition: transform 0.3s;
    }
    .menu-toggle:hover { transform: scale(1.1); }
    .bar {
        width: 60%;
        height: 4px;
        background-color: white;
        margin: 3px 0;
        transition: 0.4s;
    }
    .menu-toggle.active .bar:nth-child(2) { opacity: 0; }
    .menu-toggle.active .bar:nth-child(1) { transform: translateY(7px) rotate(45deg); }
    .menu-toggle.active .bar:nth-child(3) { transform: translateY(-7px) rotate(-45deg); }

    /* Menu Container Styling */
    .menu-container {
        position: fixed;
        top: 0;
        right: -300px; 
        width: 300px;
        height: 100%;
        background-color: rgba(50, 50, 50, 0.95);
        color: white;
        padding: 20px;
        box-sizing: border-box;
        transition: right 0.4s ease;
        z-index: 5;
        font-family: sans-serif;
    }
    .menu-container.active { right: 0; }
    .menu-container h2 { margin-top: 50px; }
    .menu-container div { margin-bottom: 10px; padding: 5px; background-color: rgba(255,255,255,0.1); border-radius:4px; }
    .menu-container button { margin: 5px 2px; padding: 5px 10px; border:none; border-radius:4px; cursor:pointer; background-color:#666; color:white; }
    .menu-container button:hover { background-color:#888; }
</style>
</head>
<body>

<canvas id="gameCanvas" width="594" height="585"></canvas>

<!-- Hamburger Menu Icon -->
<div class="menu-toggle" id="menuToggle">
    <div class="bar"></div>
    <div class="bar"></div>
    <div class="bar"></div>
</div>

<!-- Sliding Stats Menu -->
<div class="menu-container" id="statsMenu">
    <h2>Game Stats</h2>
    <div>High Score: <span id="highScore">0</span></div>
    <div>Total Movement: <span id="totalMovement">0</span></div>
    <div>Times Played: <span id="timesPlayed">0</span></div>
    <hr>
    <h3>Number of Players</h3>
    <div>
      <button onclick="setPlayerCount(1)">1</button>
      <button onclick="setPlayerCount(2)">2</button>
      <button onclick="setPlayerCount(3)">3</button>
      <button onclick="setPlayerCount(4)">4</button>
    </div>
    <hr>
<h3>Online Channel</h3>
<input type="text" id="channelName" placeholder="Channel name" style="width:90%;padding:5px;margin-bottom:10px;">

<button onclick="hostChannel()">Host</button>
<button onclick="joinChannel()">Join</button>
<input 
    type="number" 
    id="channel-input"
    placeholder="Channel number"
    style="width:90%;padding:5px;margin-bottom:10px;"
>
<div style="font-size:12px;margin-top:5px;">Up to 4 players per channel</div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const menuToggle = document.getElementById('menuToggle');
const statsMenu = document.getElementById('statsMenu');

let canvasWidth = window.innerWidth;
let canvasHeight = window.innerHeight;
canvas.width = canvasWidth;
canvas.height = canvasHeight;

// Terrain
const world = new Map();
const CHUNK_SIZE = 512;
const maxSteepness = 5;
const maxChange = 2;
const baseTerrainHeight = canvasHeight * 0.6;
const SPAWN_X = 50;
const SUN_RADIUS = 50;
const DIRT_COLOR = '#8B4513';
const GRASS_COLOR = '#e4dc8a';
const HOLE_CHANCE = 0.50; 

// Stats
let highScore = parseInt(localStorage.getItem('highScore')) || 0;
let totalMovement = parseInt(localStorage.getItem('totalMovement')) || 0;
let timesPlayed = parseInt(localStorage.getItem('timesPlayed')) || 0;
let previousWorldX = SPAWN_X;

const playerConfigs = [
    { jump: 'w', left: 'a', right: 'd', color: '#ff5733' }, // Player 1
    { jump: '5', left: 'r', right: 'y', color: '#006400' }, // Player 2
    { jump: 'o', left: 'k', right: ';', color: '#3357ff' }, // Player 3
    { jump: 'f', left: 'c', right: 'b', color: '#ff33aa' }, // Player 4
];

let players = [];
let maxPlayers = 1;

function setPlayerCount(count){
    maxPlayers = count;
    restartGame();
}

// Procedural Terrain
function generateChunk(chunkX, startHeight=baseTerrainHeight, startSteepness=0){
    if(world.has(chunkX)) return;
    const terrainData=[];
    let currentHeight=startHeight;
    let steepness=startSteepness;

    const hasHole = Math.random() < HOLE_CHANCE && chunkX>0;
    const holeStart = hasHole ? Math.floor(Math.random()*(CHUNK_SIZE-50)):-1;
    const holeEnd = hasHole ? holeStart+150:-1;

    for(let x=0;x<CHUNK_SIZE;x++){
        if(hasHole && x>=holeStart && x<=holeEnd){
            terrainData.push(canvasHeight+100);
        } else {
            steepness += (Math.random()-0.5)*maxChange*2;
            steepness = Math.min(Math.max(steepness,-maxSteepness),maxSteepness);
            currentHeight += steepness;
            currentHeight = Math.min(Math.max(currentHeight,canvasHeight*0.3),canvasHeight*0.9);
            terrainData.push(currentHeight);
        }
    }
    world.set(chunkX, {x:chunkX*CHUNK_SIZE, data:terrainData, endHeight:currentHeight, endSteepness:steepness});
}

function getTerrainHeightAt(worldX){
    const chunkX = Math.floor(worldX/CHUNK_SIZE);
    const localX = worldX % CHUNK_SIZE;
    const chunk = world.get(chunkX);
    if(chunk) return chunk.data[Math.floor(localX)];
    return baseTerrainHeight;
}

// Restart / Initialize
function restartGame(){
    players=[];
    for(let i=0;i<maxPlayers;i++){
        players.push({
            id:i,
            x:50,
            y:0,
            radius:10,
            speed:5,
            vx:0,
            vy:0,
            gravity:0.5,
            onGround:false,
            worldX:SPAWN_X,
            color:playerConfigs[i].color,
            score:0
        });
    }
    previousWorldX=SPAWN_X;
    world.clear();
    generateChunk(0);
}

// Player Movement
const keys={};
function updatePlayers(){
    let sumWorldX = 0;
    players.forEach((player,i)=>{
        const config=playerConfigs[i];

        if(keys[config.left]) player.vx=-player.speed;
        else if(keys[config.right]) player.vx=player.speed;
        else player.vx=0;

        if(keys[config.jump] && player.onGround){
            player.vy=-10;
            player.onGround=false;
        }

        player.worldX += player.vx;
        player.y += player.vy;

        if(player.y>canvasHeight+50){
            player.worldX=SPAWN_X;
            player.y=0;
            player.vx=0;
            player.vy=0;
            player.onGround=false;
        }

        const groundY=getTerrainHeightAt(player.worldX)-player.radius;
        if(player.y>=groundY){
            player.y=groundY;
            player.vy=0;
            player.onGround=true;
        } else {
            player.vy+=player.gravity;
            player.onGround=false;
        }

        player.score=Math.floor(player.worldX-SPAWN_X);
        if(player.score>highScore) highScore=player.score;

        sumWorldX += player.worldX;
    });

    // Compute average position for all players
    const avgWorldX = sumWorldX / players.length;
    if(avgWorldX>previousWorldX) totalMovement+=(avgWorldX-previousWorldX);
    previousWorldX = avgWorldX;
}

// Camera and Terrain Chunks
const camera={x:0};
function updateCameraAndChunks(){
    // Center camera on the average position of all players
    const avgX = players.reduce((sum,p)=>sum+p.worldX,0)/players.length;
    camera.x = avgX - canvasWidth/2;
    camera.x = Math.max(0,camera.x);

    const startChunkX=Math.floor(camera.x/CHUNK_SIZE);
    const endChunkX=Math.floor((camera.x+canvasWidth)/CHUNK_SIZE);
    for(let cx=startChunkX-1;cx<=endChunkX+1;cx++){
        if(!world.has(cx)){
            const prevChunk=world.get(cx-1);
            if(prevChunk) generateChunk(cx,prevChunk.endHeight,prevChunk.endSteepness);
            else generateChunk(cx);
        }
    }
}
function hostChannel(){
    const channelNumber = parseInt(document.getElementById("channel-input").value);

    if(isNaN(channelNumber)){
        alert("Enter a valid channel number!");
        return;
    }

    isHost = true;

    ydoc = new Y.Doc();

    provider = new WebrtcProvider(
        "dunerise-" + channelNumber,
        ydoc
    );

    yPlayers = ydoc.getArray("players");

    // Host initializes slots if empty
    if(yPlayers.length === 0){
        for(let i=0;i<4;i++){
            yPlayers.push([SPAWN_X, 0, false, 0]);
        }
    }

    // Host is always slot 0
    myPlayerIndex = 0;

    maxPlayers = 4;
    restartGame();

    console.log("Channel hosted:", channelNumber);
}
    function pickFreeSlot(){
    for(let i = 0; i < yPlayers.length; i++){
        let p = yPlayers.get(i);

        // If position still at initial spawn = unused slot
        if(p[0] === SPAWN_X && p[1] === 0){
            return i;
        }
    }
    return -1; // No open slot
}
    function joinChannel(){

    const channelNumber = parseInt(document.getElementById("channel-input").value);

    if(isNaN(channelNumber)){
        alert("Enter a valid channel number!");
        return;
    }

    isHost = false;

    // Create a new Yjs document instance
    ydoc = new Y.Doc();

    // Connect to the WebRTC room
    provider = new WebrtcProvider(
        "dunerise-" + channelNumber,
        ydoc
    );

    // Shared array of up to 4 player slots
    yPlayers = ydoc.getArray("players");

    console.log("Connecting to channel:", channelNumber);

    //
    // We wait until host has created player slots
    //
    const waitForHost = setInterval(() => {

        // Host should have already created 4 slots
        if(yPlayers.length >= 4){

            clearInterval(waitForHost);

            // Find an open slot
            myPlayerIndex = pickFreeSlot();

            if(myPlayerIndex === -1){
                alert("This channel is full (4 players).");
                return;
            }

            maxPlayers = 4;

            console.log(
                "Joined channel:",
                channelNumber,
                " â†’ Assigned slot:",
                myPlayerIndex
            );

            restartGame();
        }

    }, 300);
}
function joinChannel(){
    const channelNumber = parseInt(document.getElementById("channel-input").value);

    if(isNaN(channelNumber)){
        alert("Enter a valid channel number!");
        return;
    }

    isHost = false;

    ydoc = new Y.Doc();

    provider = new WebrtcProvider(
        "dunerise-" + channelNumber,
        ydoc
    );

    yPlayers = ydoc.getArray("players");

    const waitForHost = setInterval(() => {
        if(yPlayers.length >= 1){

            clearInterval(waitForHost);

            myPlayerIndex = pickFreeSlot();

            maxPlayers = 4;
            restartGame();

            console.log("Joined channel:", channelNumber, "Slot:", myPlayerIndex);
        }
    }, 300);
}
// Drawing
function drawTerrain(){
    ctx.fillStyle=DIRT_COLOR;
    for(const [chunkKey,chunk] of world){
        if(chunk.x+CHUNK_SIZE>camera.x && chunk.x<camera.x+canvasWidth){
            ctx.beginPath();
            ctx.moveTo(chunk.x-camera.x,canvasHeight);
            for(let i=0;i<CHUNK_SIZE;i++){
                ctx.lineTo(chunk.x+i-camera.x,chunk.data[i]);
            }
            ctx.lineTo(chunk.x+CHUNK_SIZE-camera.x,canvasHeight);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(chunk.x-camera.x,chunk.data[0]);
            for(let i=0;i<CHUNK_SIZE;i++){
                ctx.lineTo(chunk.x+i-camera.x,chunk.data[i]);
            }
            ctx.strokeStyle=GRASS_COLOR;
            ctx.lineWidth=2;
            ctx.stroke();
        }
    }
}

function drawPlayers(){
    players.forEach(player=>{
        const screenX=player.worldX-camera.x;
        ctx.beginPath();
        ctx.arc(screenX,player.y,player.radius,0,Math.PI*2);
        ctx.fillStyle=player.color;
        ctx.fill();
        ctx.closePath();
    });
}

function drawSun(){
    const sunX=SUN_RADIUS+30;
    const sunY=SUN_RADIUS+30;
    ctx.beginPath();
    ctx.arc(sunX,sunY,SUN_RADIUS,0,Math.PI*2);
    ctx.fillStyle='#FFD700';
    ctx.fill();
    ctx.closePath();
    ctx.strokeStyle='#FFD700';
    ctx.lineWidth=3;
    const numRays=16;
    for(let i=0;i<numRays;i++){
        const angle=(i/numRays)*Math.PI*2;
        const startX=sunX+Math.cos(angle)*(SUN_RADIUS+5);
        const startY=sunY+Math.sin(angle)*(SUN_RADIUS+5);
        const endX=sunX+Math.cos(angle)*(SUN_RADIUS+25);
        const endY=sunY+Math.sin(angle)*(SUN_RADIUS+25);
        ctx.beginPath();
        ctx.moveTo(startX,startY);
        ctx.lineTo(endX,endY);
        ctx.stroke();
    }
}

function displayScore(){
    const avgScore = players.reduce((sum, p) => sum + p.score, 0) / players.length;
    ctx.fillStyle='#000';
    ctx.font='40px Arial';
    ctx.textAlign='center';
    ctx.fillText(`Score: ${Math.floor(avgScore)}`, canvasWidth/2, 50);
}

function updateStats(){
    localStorage.setItem('highScore',highScore);
    localStorage.setItem('totalMovement',Math.floor(totalMovement));
    localStorage.setItem('timesPlayed',timesPlayed);
    document.getElementById('highScore').textContent=highScore;
    document.getElementById('totalMovement').textContent=Math.floor(totalMovement);
    document.getElementById('timesPlayed').textContent=timesPlayed;
}

// Menu toggle
menuToggle.addEventListener('click',()=>{
    menuToggle.classList.toggle('active');
    statsMenu.classList.toggle('active');
});

// Game loop
function gameLoop(){
    ctx.clearRect(0,0,canvasWidth,canvasHeight);
    updatePlayers();
    updateCameraAndChunks();
    drawSun();
    drawTerrain();
    drawPlayers();
    displayScore();
    updateStats();
    requestAnimationFrame(gameLoop);
}

// Input
document.addEventListener('keydown',(e)=>{ keys[e.key.toLowerCase()]=true; });
document.addEventListener('keyup',(e)=>{ keys[e.key.toLowerCase()]=false; });

// Window resize
window.addEventListener('resize',()=>{
    canvasWidth=window.innerWidth;
    canvasHeight=window.innerHeight;
    canvas.width=canvasWidth;
    canvas.height=canvasHeight;
    world.clear();
    generateChunk(Math.floor(players[0].worldX/CHUNK_SIZE));
});

// Increment timesPlayed on first load
if(!localStorage.getItem('gameInitialized')){
    timesPlayed=1;
    localStorage.setItem('gameInitialized','true');
} else {
    timesPlayed=parseInt(localStorage.getItem('timesPlayed'))||0;
    timesPlayed++;
    localStorage.setItem('timesPlayed',timesPlayed);
}

// Start game
restartGame();
gameLoop();
</script>

</body>
</html>
